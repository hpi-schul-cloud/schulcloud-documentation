"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[1986],{6121:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"backend/Coding-Guidelines/code-style","title":"Code Style","description":"Function","source":"@site/docs/backend/Coding-Guidelines/code-style.md","sourceDirName":"backend/Coding-Guidelines","slug":"/backend/Coding-Guidelines/code-style","permalink":"/docs/backend/Coding-Guidelines/code-style","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/backend/Coding-Guidelines/code-style.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Access legacy Code","permalink":"/docs/backend/Coding-Guidelines/access-legacy-code"},"next":{"title":"Configuration","permalink":"/docs/backend/Coding-Guidelines/configuration"}}');var t=i(4848),r=i(8453);const o={},a="Code Style",c={},l=[{value:"Function",id:"function",level:2},{value:"Naming functions",id:"naming-functions",level:3},{value:"&quot;is...&quot;",id:"is",level:4},{value:"&quot;check...&quot;",id:"check",level:4},{value:"&quot;has...&quot;",id:"has",level:4},{value:"Avoid direct returns of computations",id:"avoid-direct-returns-of-computations",level:3},{value:"avoid directly passing function results as parameters",id:"avoid-directly-passing-function-results-as-parameters",level:3},{value:"explicit return type",id:"explicit-return-type",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Avoid the &quot;I&quot; for interfaces",id:"avoid-the-i-for-interfaces",level:3},{value:"Classes",id:"classes",level:2},{value:"Order of declarations",id:"order-of-declarations",level:3},{value:"Naming classes",id:"naming-classes",level:3},{value:"Do NOT use JsDoc",id:"do-not-use-jsdoc",level:2},{value:"Do use empty lines",id:"do-use-empty-lines",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"code-style",children:"Code Style"})}),"\n",(0,t.jsx)(n.h2,{id:"function",children:"Function"}),"\n",(0,t.jsx)(n.h3,{id:"naming-functions",children:"Naming functions"}),"\n",(0,t.jsx)(n.p,{children:"The name of a function should clearly communicate what it does. There should be no need to read the implementation of a function to understand what it does."}),"\n",(0,t.jsx)(n.p,{children:"There are a few keywords that we use with specific meaning:"}),"\n",(0,t.jsx)(n.h4,{id:"is",children:'"is..."'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"isTask()"}),", ",(0,t.jsx)(n.code,{children:"isPublished()"}),", ",(0,t.jsx)(n.code,{children:"isAuthenticated()"}),", ",(0,t.jsx)(n.code,{children:"isValid()"})]}),"\n",(0,t.jsx)(n.p,{children:'A function with the prefix "is..." is checking wether the input belongs to a certain (sub)class, or fulfils a specific criteria.'}),"\n",(0,t.jsx)(n.p,{children:"The function should return a boolean, and have no sideeffects."}),"\n",(0,t.jsx)(n.h4,{id:"check",children:'"check..."'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"checkPermission()"}),", ",(0,t.jsx)(n.code,{children:"checkInputIsValid()"})]}),"\n",(0,t.jsx)(n.p,{children:'A function with the prefix "check..." is checking the condition described in its name, throwing an error if it does not apply.'}),"\n",(0,t.jsx)(n.h4,{id:"has",children:'"has..."'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"hasPermission()"}),","]}),"\n",(0,t.jsx)(n.p,{children:'similar to "is...", the prefix "has..." means that the function is checking a condition, and returns a boolean. It does NOT throw an error.'}),"\n",(0,t.jsx)(n.h3,{id:"avoid-direct-returns-of-computations",children:"Avoid direct returns of computations"}),"\n",(0,t.jsx)(n.p,{children:"avoid directly returning the result of some computation. Instead, use a variable to give the result of the computation a name."}),"\n",(0,t.jsx)(n.p,{children:"Exceptions can be made when the result of the computation is already clear from the function name, and the function is sufficiently simple to not occlude its meaning."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class SomeClass {\n    public doSomething(): FileRecordParams[] {\n        // ... more logic here\n        const fileRecordParams = fileRecords.map((fileRecord) => Mapper.toParams(fileRecord));\n        // hint: this empty line can be increase the readability\n        return fileRecordParams;\n    }\n\n    public getName(): string {\n        return this.name;\n    }\n\n    public getInfo(): FileInfo {\n        // ... more logic here\n        return { name, parentId, parentType }; // but if the return include many keys, please put it first to a const\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"avoid-directly-passing-function-results-as-parameters",children:"avoid directly passing function results as parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const badExample = (): void => {\n    doSomething(this.extractFromParams(params), this.createNewConfiguration());\n}\n\nconst goodExample = (): void => {\n    const neededParams = this.extractFromParams(params);\n    const configuration = this.createNewConfiguration();\n    doSomething(neededParams, configuration);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"explicit-return-type",children:"explicit return type"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class SomeClass {\n    public doSomething(): FileRecord[] {\n        // ...\n        // const fileRecords = ...\n        return fileRecords;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,t.jsx)(n.h3,{id:"avoid-the-i-for-interfaces",children:'Avoid the "I" for interfaces'}),"\n",(0,t.jsx)(n.p,{children:'In most cases, it should not matter to the reader/external code wether something is an interface or an implementation. Only prefix the "I" when necessary, or when its specifically important to the external code to know that its an interface, for example when external code is required to implement the interface.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Typescript",children:"interface CourseRepo {\n    getById(id): Course\n    // ...\n}\n\nclass InMemoryCourseRepo implements CourseRepo {\n    getById(id): Course {\n        return new Course()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,t.jsx)(n.h3,{id:"order-of-declarations",children:"Order of declarations"}),"\n",(0,t.jsx)(n.p,{children:"Classes are declared in the following order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"properties"}),"\n",(0,t.jsx)(n.li,{children:"constructor"}),"\n",(0,t.jsx)(n.li,{children:"methods"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Typescript",children:"export class Course {\n  // 1. properties\n  name: string;\n\n  // more properties...\n\n  // 2. constructor\n  constructor(props: { name: string }) {\n    // ...\n  }\n\n  // 3. methods\n  public getShortTitle(): string {\n    // ...\n  }\n\n  // more methods...\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"naming-classes",children:"Naming classes"}),"\n",(0,t.jsx)(n.p,{children:"Classes should be named in CamelCase. They should have a Suffix with the kind of Object they represent, and from the beginning to the end go from specific to general."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"CourseController"}),"\n",(0,t.jsx)(n.li,{children:"CourseCreateBodyParam"}),"\n",(0,t.jsx)(n.li,{children:"CourseCreateQueryParam"}),"\n",(0,t.jsx)(n.li,{children:"CourseCreateResponse"}),"\n",(0,t.jsx)(n.li,{children:"CourseDtoMapper"}),"\n",(0,t.jsx)(n.li,{children:"CourseUc"}),"\n",(0,t.jsx)(n.li,{children:"CourseAuthorisationDto"}),"\n",(0,t.jsx)(n.li,{children:"CourseDo"}),"\n",(0,t.jsx)(n.li,{children:"CourseService"}),"\n",(0,t.jsx)(n.li,{children:"CourseRepo"}),"\n",(0,t.jsx)(n.li,{children:"CourseEntity"}),"\n",(0,t.jsx)(n.li,{children:"CourseEntityMapper"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"do-not-use-jsdoc",children:"Do NOT use JsDoc"}),"\n",(0,t.jsx)(n.p,{children:"You should always try to write code in a way that does not require further explanation to understand. Use proper names for functions and variables, and extract code and partial results into functions or variables in order to name them. If you feel like a function needs a JsDoc, treat that as a codesmell, and try to rewrite the code in a way that is more self-explanatory."}),"\n",(0,t.jsx)(n.h2,{id:"do-use-empty-lines",children:"Do use empty lines"}),"\n",(0,t.jsx)(n.p,{children:"empty lines help to structure code. Use them wherever you want to seperate parts of a function from each other (and think about further extracting functions). Common uses include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"before return statement"}),"\n",(0,t.jsx)(n.li,{children:"before and after an if/else statement"}),"\n",(0,t.jsx)(n.li,{children:"between test sections (arrange, act, assert)"}),"\n",(0,t.jsx)(n.li,{children:'between "it()" statements in tests'}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);