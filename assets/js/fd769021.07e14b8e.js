"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[8466],{6030:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"frontend/WritingTests","title":"Writing Tests","description":"How to write valuable, reliable tests, that are easy to maintain.","source":"@site/docs/frontend/5_WritingTests.md","sourceDirName":"frontend","slug":"/frontend/WritingTests","permalink":"/docs/frontend/WritingTests","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/frontend/5_WritingTests.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"How To","permalink":"/docs/frontend/HowTo"},"next":{"title":"Accessibility (A11y)","permalink":"/docs/frontend/Accessibility"}}');var o=t(4848),i=t(8453);const r={sidebar_position:6},l="Writing Tests",a={},c=[{value:"Basics",id:"basics",level:2},{value:"Unit-Tests vs. Component-Tests",id:"unit-tests-vs-component-tests",level:3},{value:"Unit-Tests",id:"unit-tests",level:4},{value:"Component-Tests",id:"component-tests",level:4},{value:"Positive &amp; negative Tests",id:"positive--negative-tests",level:3},{value:"Use Vue-Test-Utils",id:"use-vue-test-utils",level:3},{value:"Use TypeScript",id:"use-typescript",level:3},{value:"Name your tests like your components",id:"name-your-tests-like-your-components",level:3},{value:"Structure your tests using (multiple) &quot;describe&quot;-blocks",id:"structure-your-tests-using-multiple-describe-blocks",level:3},{value:"Name the test like a sentence &quot;it should...&quot;",id:"name-the-test-like-a-sentence-it-should",level:3},{value:"data-testids",id:"data-testids",level:3},{value:"Setup-methods",id:"setup-methods",level:3},{value:"Testing",id:"testing",level:2},{value:"Events",id:"events",level:3},{value:"Testing Asynchronous Behavior",id:"testing-asynchronous-behavior",level:3},{value:"Exceptions",id:"exceptions",level:3},{value:"console.error",id:"consoleerror",level:3},{value:"Testing Composables",id:"testing-composables",level:3},{value:"Mocking",id:"mocking",level:2},{value:"Mocking injections",id:"mocking-injections",level:3},{value:"Mocking Vuex-Store",id:"mocking-vuex-store",level:3},{value:"Mocking a vuex-store in a component",id:"mocking-a-vuex-store-in-a-component",level:4},{value:"Testing a store",id:"testing-a-store",level:4},{value:"Mocking Composables",id:"mocking-composables",level:3},{value:"Mocking Pinia-Stores",id:"mocking-pinia-stores",level:3},{value:"Components that are hard to test",id:"components-that-are-hard-to-test",level:2},{value:"End-To-End-Tests",id:"end-to-end-tests",level:2},{value:"Code-Coverage",id:"code-coverage",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"writing-tests",children:"Writing Tests"})}),"\n",(0,o.jsx)(n.p,{children:"How to write valuable, reliable tests, that are easy to maintain."}),"\n",(0,o.jsx)(n.h2,{id:"basics",children:"Basics"}),"\n",(0,o.jsx)(n.p,{children:"Writing good tests that cover all aspects of your code, leads to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"confidence"}),": to refactor your code"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"higher code quality"}),": as you review your code and identify problems when writing tests"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"well documented code"}),": as your tests describe how your code works"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"and by that to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"developer happiness"})," :-)"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"unit-tests-vs-component-tests",children:"Unit-Tests vs. Component-Tests"}),"\n",(0,o.jsx)(n.h4,{id:"unit-tests",children:"Unit-Tests"}),"\n",(0,o.jsxs)(n.p,{children:["Unit-Tests are ",(0,o.jsx)(n.strong,{children:"WhiteBox-Tests"}),". So they may use knowledge of internals of the code. They are well suited for testing e.g. ",(0,o.jsx)(n.strong,{children:"composables"})," and ",(0,o.jsx)(n.strong,{children:"stores"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"component-tests",children:"Component-Tests"}),"\n",(0,o.jsxs)(n.p,{children:["Component-Tests are ",(0,o.jsx)(n.strong,{children:"BlackBox-Tests"}),". So they are not allowed to use any knowledge of the internals of the component.\nThey ensure the stability of the ",(0,o.jsx)(n.strong,{children:"public interface"})," of the component (aka its methods, props, events etc.).\nThe enable us to ",(0,o.jsx)(n.strong,{children:"refactor"})," the internals of our components later on."]}),"\n",(0,o.jsx)(n.h3,{id:"positive--negative-tests",children:"Positive & negative Tests"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"positive tests"})," test the default cases of your code = ",(0,o.jsx)(n.strong,{children:"how it should work"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"negative tests"})," test ",(0,o.jsx)(n.strong,{children:"error-cases"})," or ",(0,o.jsx)(n.strong,{children:"exception"}),"-behaviour"]}),"\n",(0,o.jsx)(n.li,{children:"you need to write both to ensure your component works correctly"}),"\n",(0,o.jsxs)(n.li,{children:["think of edge-cases that might break your component e.g. when providing input to the component:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"numbers"}),": high numbers, negative numbers, float<->integer, at the edge of a range that is expected..."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"dates"}),": none existing dates e.g. 30th February 2023, far away future,..."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"strings"}),": umlauts, url-special-characters (?, &, =, //: ), very long strings for names, long strings without linebreaks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"totally incorrect data"}),": e.g. giving a string instead of a number"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"use-vue-test-utils",children:"Use Vue-Test-Utils"}),"\n",(0,o.jsxs)(n.p,{children:["For testing our Vue-Components we use the ",(0,o.jsx)(n.strong,{children:"Vue Test Utils"}),". Vue Test Utils is a library that provides methods to help you write tests for your Vue components. It provides methods to mount, shallow mount, and render components, as well as methods to simulate events and find elements in the rendered output."]}),"\n",(0,o.jsx)(n.p,{children:"Some functionality it provides:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"mount()"}),": create a wrapper around the component and instantiate it"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"shallowMount()"}),": create a shallow wrapper of the component being tested with childcomponents being mocked"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"setMethods()"}),": mock function on the component"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"setProps()"}),": set a specific set of props on the component"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"findComponent()"}),": finds a component by it's class, name or ref"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"findAllComponents()"}),": finds all components by it's class, name or ref"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/api/wrapper/#find",children:"find() / findAll()"})}),": search for html elements using html-selectors","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"deprecated for finding Components"})}),"\n",(0,o.jsx)(n.li,{children:"use findComponent() or findAllComponents() instead"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"setData()"}),": set specific data on the component"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"trigger()"})," + ",(0,o.jsx)(n.strong,{children:"emit()"}),": test events and the flow of data"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["We think the ",(0,o.jsx)(n.strong,{children:"Vue Test Utils-documentation"})," is a valuable resource for learning how to test Vue-Components and a very good starting point on how to test certain aspects of your component. Please have a look at ",(0,o.jsx)(n.a,{href:"https://test-utils.vuejs.org/guide",children:"https://test-utils.vuejs.org/guide"})]}),"\n",(0,o.jsx)(n.h3,{id:"use-typescript",children:"Use TypeScript"}),"\n",(0,o.jsx)(n.p,{children:"Use TypeScript for your components and for your unit-tests. This way many errors can be prevented early on, as you can detect them already in your IDE."}),"\n",(0,o.jsx)(n.h3,{id:"name-your-tests-like-your-components",children:"Name your tests like your components"}),"\n",(0,o.jsxs)(n.p,{children:["Tests should be named after their Component using ",(0,o.jsx)(n.strong,{children:".unit.ts"})," as the extension:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-JavaScript",children:"HelloWorld.vue\nHelloWorld.unit.ts\n"})}),"\n",(0,o.jsx)(n.h3,{id:"structure-your-tests-using-multiple-describe-blocks",children:'Structure your tests using (multiple) "describe"-blocks'}),"\n",(0,o.jsx)(n.p,{children:"Especially in large test-files it is very helpful for the reader to have a tree-like structure grouping the tests. So use describe blocks to group tests that are related to the same aspect of your code/the functionality."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"describe block that contains the filename in the root-level of the test-file"}),"\n",(0,o.jsx)(n.li,{children:"sub-describe-blocks for groups of tests focussing the same aspects of your code"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"describe('@components/share/ImportModal', () => {\n    describe('when action button is clicked', () => {\n        // ...\n    });\n\n    // ...\n\n    describe(\"when backend returns an error\", () => {\n\n    });\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Example taken from here ",(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=OIpfWTThrK8",children:"Vue NYC - Component Tests with Vue.js - Matt O'Connell"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"describe('@components/something/AddButton', () => {\n    describe(':props', () => {\n        it(':label - should render a button with the passed-in label text', () => { /* ... */ })\n    });\n\n    // ...\n\n    describe(\"@events\", () => {\n        it('@add - should emit an \"add\" event when the button is clicked', () => { /* ... */ })\n    });\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Hint"}),": ",(0,o.jsx)(n.em,{children:"maybe you should extract functionality from your component if this is needed e.g. to find a certain test in your file"})]}),"\n",(0,o.jsx)(n.h3,{id:"name-the-test-like-a-sentence-it-should",children:'Name the test like a sentence "it should..."'}),"\n",(0,o.jsx)(n.p,{children:"There is a reason we use the it-alias for writing our code and not the test-method: we want to describe the aspect that is tested in a natural sentence. That's why it is best practice to start your test with: it('should ...');"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"Bad:\nit('name changes on button click')\n// ...\n\nGood:\nit('should display the info text', /* ... */ );\nit('should not render migration start button', /* ... */ );\nit('should return the translation', /* ... */ );\n"})}),"\n",(0,o.jsx)(n.h3,{id:"data-testids",children:"data-testids"}),"\n",(0,o.jsx)(n.p,{children:"Data-testids are attributes to HTML-elements that are solely used to enable tests to find and check a certain aspect of that tag (often to check the contained text against some expected value)."}),"\n",(0,o.jsxs)(n.p,{children:["We decided to unify the way data-testid's should be named in Frontend Arch Group: ",(0,o.jsx)(n.a,{href:"https://docs.dbildungscloud.de/x/mYHADQ",children:"Meeting 2022-11-04"})]}),"\n",(0,o.jsxs)(n.p,{children:["Please use ",(0,o.jsx)(n.code,{children:'<div ... data-testid="some-example" ...>'})," in your HTML-code if you want to define a data-testid."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"do not use uppercase-characters"}),"\n",(0,o.jsx)(n.li,{children:"only use one dash - right after data"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You can later on check this using:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'// CopyResultModal.unit.ts\nexpect(\n  wrapper.find(\'[data-testid="copy-result-notifications"]\').text()\n).toContain(\n  wrapper.vm.$i18n.t("components.molecules.copyResult.fileCopy.error")\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:"We also recommend to use refs instead of data-testids. But if you do that you ensure not to remove them once they are in the code... as they can be used in the component-code and for testing:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://vuejs.org/guide/essentials/template-refs.html",children:"VueJs - template refs"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/api/#ref",children:"VueTestUtils - ref"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"setup-methods",children:"Setup-methods"}),"\n",(0,o.jsx)(n.p,{children:'Separate your setup from your actual tests: If you need a more complex setup to test something - write a scope method called "setup" for it. Write it in a reusable and configurable way, in order to reuse most of it in several groups of tests. You will get small and easily readable tests and no redudant setup-code inside your tests that contains small differences that are hard to detect.'}),"\n",(0,o.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,o.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,o.jsxs)(n.p,{children:["Use the trigger()-method to simulate a events\n",(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/guides/#testing-key-mouse-and-other-dom-events",children:"Testing Key, Mouse and other DOM events"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mouse-Click"}),": ",(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/guides/#trigger-events",children:"VueTestUtils - trigger events"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Keyboard-Input"}),": ",(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/guides/#keyboard-example",children:"VueTestUtils - keyboard example"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Drag & Drop"}),": trigger the events (e.g. dragstart, drop) and check for emitted events as reaction to that"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Event from a child component"}),": ",(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/guides/#emitting-event-from-child-component",children:"VueTestUtils - emitting from child component"})]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"testing-asynchronous-behavior",children:"Testing Asynchronous Behavior"}),"\n",(0,o.jsxs)(n.p,{children:["You can test asynchronous behavior by using ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"Vue.nextTick()"})}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"await Vue.nextTick();\n// ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["OR by ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"trigger"})}),"ing an effect and ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"await"})}),"ing this effect to take place:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'const btnNext = wrapper.find(`[data-testid="dialog-next"]`);\nawait btnNext.trigger("click");\n// ...\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"see also"}),": ",(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/guides/#testing-asynchronous-behavior",children:"VueTestUtils - Testing Asynchronous Behavior"})]}),"\n",(0,o.jsx)(n.h3,{id:"exceptions",children:"Exceptions"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"await expect(() => copyModule.copy(payload)).rejects.toThrow(\n    `CopyProcess unknown type: ${payload.type}`\n);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"consoleerror",children:"console.error"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'// UserMigration.page.unit.ts\nconst consoleErrorSpy = jest\n    .spyOn(console, "error")\n    .mockImplementation();\n\n// ...\n\nexpect(consoleErrorSpy).toHaveBeenCalledWith(\n    expect.any(ApplicationError)\n);\nconsoleErrorSpy.mockRestore();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"testing-composables",children:"Testing Composables"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://test-utils.vuejs.org/guide/advanced/reusability-composition.html#testing-composables",children:"VueTestUtils - Testing composables"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"mocking",children:"Mocking"}),"\n",(0,o.jsx)(n.p,{children:'Replaces methods, instances of classes (e.g. stores) with some functionality, that e.g. simply returns a value you want to use in your test. By mocking you can easily simulate certain scenarios like failing requests or certain return values from any "external" (as in "not part of the code i am currently testing") functionality.\nJest provides very helpful methods for that.\nExamples from our codebase:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"const mock = jest.fn().mockReturnValue(expectedTranslation);\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"copyModuleMock.copyByShareToken = jest.fn()\n    .mockResolvedValue(copyResults);\n"})}),"\n",(0,o.jsx)(n.p,{children:"They can easily be tested like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"expect(copyModuleMock.copyByShareToken).toHaveBeenCalled();\n"})}),"\n",(0,o.jsx)(n.p,{children:"Or more specific like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"expect(addFileMetaDataSpy).toHaveBeenCalledWith(\n    expect.objectContaining<FileMetaListResponse>({ size: 2 } as FileMetaListResponse)\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See also here: ",(0,o.jsx)(n.a,{href:"https://test-utils.vuejs.org/migration/",children:"VueTestUtils mount - mocks and stubs are now in global"})]}),"\n",(0,o.jsx)(n.h3,{id:"mocking-injections",children:"Mocking injections"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://v1.test-utils.vuejs.org/guides/#mocking-injections",children:"Vue.js - Mocking injections"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://test-utils.vuejs.org/guide/advanced/reusability-composition.html#provide-inject",children:"VueTestUtils - provide / inject"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"mocking-vuex-store",children:"Mocking Vuex-Store"}),"\n",(0,o.jsx)(n.h4,{id:"mocking-a-vuex-store-in-a-component",children:"Mocking a vuex-store in a component"}),"\n",(0,o.jsxs)(n.p,{children:["Example file: ",(0,o.jsx)(n.code,{children:"src/components/administration/AdminMigrationSection.unit.ts"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'import { createModuleMocks } from "@/utils/mock-store-module";\nimport YourModule from "@/store/YourModule";\n\nlet yourModule: jest.Mocked<YourModule>;\n\nschoolsModule = createModuleMocks(YourModule, {\n    yourMethodName: {\n        // ...\n    },\n    ...yourGetters,\n}) as jest.Mocked<YourModule>;\n\n\nmount(YourComponentToBeTested, {\n    ...createComponentMocks({\n        // ...\n    }),\n    provide: {\n        yourModule,\n    },\n});\n\nexpect(yourModule.yourMethodName).toHaveBeenCalledWith( /* ... */ );\n'})}),"\n",(0,o.jsx)(n.h4,{id:"testing-a-store",children:"Testing a store"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'import YourModule from "./your-module";\n\nconst yourModule = new YourModule({});\n\n// ...\n\n// using `jest.spyOn()`\nit("should call something", () => {\n    const yourActionNameMock = jest.spyOn(yourModule, "yourActionName");\n    yourModule.yourActionName();\n    expect(yourActionNameMock).toHaveBeenCalled();\n});\n\n// or using a method directly\nit("should set something", () => {\n    yourModule.setLoading(true);\n    expect(yourModule.getLoading).toBe(true);\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"mocking-composables",children:"Mocking Composables"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes - if a composable is simple and does not create sideeffects - it is okay to use it in the tests and avoid mocking it."}),"\n",(0,o.jsx)(n.p,{children:"That's beneficial as it let's us stick to the BlackBox-Idea: we should not know what the component is using internally."}),"\n",(0,o.jsx)(n.p,{children:"If you need to mock a composable, you can simple do this like in the following example. You only have to ensure to return everything the composable returns... but mocked versions of it."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'// ...\njest.spyOn(ourExampleComposable, "useExample").mockReturnValue({\n  // return mocks of what the composable would have returned\n});\n// ...\n'})}),"\n",(0,o.jsx)(n.h3,{id:"mocking-pinia-stores",children:"Mocking Pinia-Stores"}),"\n",(0,o.jsxs)(n.p,{children:["Using our internal function ",(0,o.jsx)(n.code,{children:"mockedPinaStoreTyping(useExampleStore)"})," mocks the given store and returns a correctly typed mocked instance of this store. All actions of the store are replaced by jest.fn() mock-functions."]}),"\n",(0,o.jsx)(n.p,{children:"All PiniaStores should be mocked using this functionality."}),"\n",(0,o.jsx)(n.p,{children:"For integration-tests we use the original stores."}),"\n",(0,o.jsx)(n.p,{children:"Example from RoomDetails.page.unit.ts:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'import { mockedPiniaStoreTyping } from "@@/tests/test-utils";\n\n// ...\n\ndescribe("...", ()=> {\n    const setup = (/* ... */) => {\n        // ...\n        const roomDetailsStore = mockedPiniaStoreTyping(useRoomDetailsStore);\n        // ...\n        return {\n            roomDetailsStore,\n            // ...\n        };\n    };\n\n    describe("...", () => {\n        it("should ...", async () => {\n            const { wrapper, roomDetailsStore, room } = setup();\n\n            // ...\n            expect(roomDetailsStore.createBoard).toHaveBeenCalledWith(\n                room.id,\n                serverApi.BoardLayout.Columns,\n                "pages.roomDetails.board.defaultName"\n            );\n        });\n    });\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"components-that-are-hard-to-test",children:"Components that are hard to test"}),"\n",(0,o.jsxs)(n.p,{children:["If you ever get into trouble to write good tests for your compents or code in general - this might be an indicator, that ",(0,o.jsx)(n.strong,{children:"maybe your code is not structured good enough"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Consider:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"spliting your component into smaller sub-components with a small API"}),"\n",(0,o.jsx)(n.li,{children:"extracting functionality into one or mutliple composables"}),"\n",(0,o.jsx)(n.li,{children:"using an existing composable (from VueUse or an existing one in the project)"}),"\n",(0,o.jsx)(n.li,{children:"using an existing vuetify-component instead of writing it all yourself"}),"\n",(0,o.jsx)(n.li,{children:"reshaping the communication workflow (parameters, events, inject/provide, stores, composables)"}),"\n",(0,o.jsx)(n.li,{children:"(replacing a Vuex-store with a Pinia-store)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For more details on how to write good components and how to split your components: have a look at this great article of Olli: (tbd)"}),"\n",(0,o.jsx)(n.h2,{id:"end-to-end-tests",children:"End-To-End-Tests"}),"\n",(0,o.jsx)(n.p,{children:"(aka Integration/Acceptance/System-Tests)"}),"\n",(0,o.jsxs)(n.p,{children:["End-to-End-Tests are developed in a seperate repository ",(0,o.jsx)(n.a,{href:"https://github.com/hpi-schul-cloud/end-to-end-tests",children:"end-to-end-tests"})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://docs.dbildungscloud.de/x/tAgrCg",children:"Documentation of e2e tests"})}),"\n",(0,o.jsx)(n.h2,{id:"code-coverage",children:"Code-Coverage"}),"\n",(0,o.jsxs)(n.p,{children:["For monitoring our code-coverage we are using ",(0,o.jsx)(n.a,{href:"https://www.codacy.com",children:"Codacy"}),". The current status can be seen on this ",(0,o.jsx)(n.a,{href:"https://app.codacy.com/gh/hpi-schul-cloud/nuxt-client/dashboard/",children:"Dashboard"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);