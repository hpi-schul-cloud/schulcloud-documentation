"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[6699],{4159:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"backend/architecture","title":"Software Architecture","description":"Goals","source":"@site/docs/backend/architecture.md","sourceDirName":"backend","slug":"/backend/architecture","permalink":"/docs/backend/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/backend/architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Migrations","permalink":"/docs/backend/Migrations"},"next":{"title":"Detect Dependency Cycles","permalink":"/docs/backend/detect-dependency-cycles"}}');var s=i(4848),r=i(8453);const o={},a="Software Architecture",l={},d=[{value:"Goals",id:"goals",level:2},{value:"Principles",id:"principles",level:2},{value:"Server Layer Architecture",id:"server-layer-architecture",level:2},{value:"Domain Layer",id:"domain-layer",level:3},{value:"API Layer",id:"api-layer",level:3},{value:"Repository Layer",id:"repository-layer",level:3},{value:"Modules",id:"modules",level:2},{value:"Api Modules",id:"api-modules",level:3},{value:"Horizontal Architecture",id:"horizontal-architecture",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"software-architecture",children:"Software Architecture"})}),"\n",(0,s.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,s.jsx)(n.p,{children:"Our architecture aims to achieve the following goals:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Maintainability","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"it should be easy as possible to make changes that do not change the behaviour of the system (refactoring)"}),"\n",(0,s.jsx)(n.li,{children:"it should be easy to exchange entire components of the system, without impact on other components."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Extendability","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"it should be easy to add new functionality to the system"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Agility","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"it should be easy to react to changing requirements during our development process"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Change Security"}),"\n",(0,s.jsx)(n.li,{children:"it should be easy to determine the correctness of the system after making any changes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"principles",children:"Principles"}),"\n",(0,s.jsx)(n.p,{children:"In order to achieve these goals, we try to follow the principles detailed below.\nThese principles apply to all layers of our software, from lines of code and methods to modules and architectural layers."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Responsibility / Seperation of Concerns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"each piece of code should have a single layer of abstraction/detail"}),"\n",(0,s.jsx)(n.li,{children:"each piece of code should have a single reason to change"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open/Closed Principle"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"design to be open to extension, but closed to modification"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Liskov Substitution"})}),"\n",(0,s.jsx)(n.li,{children:"the specific input may be more generic than its interface"}),"\n",(0,s.jsx)(n.li,{children:"the specific output may be more specialized than its interface"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interface Segregation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"multiple small interfaces are preferred over big interfaces"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependency Inversion Principle"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"always depend on interfaces, not implementations"}),"\n",(0,s.jsx)(n.li,{children:"higher level parts should not depend on lower level parts."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep It Simple (KISS)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"any piece of code should be simple and readable"}),"\n",(0,s.jsx)(n.li,{children:"any logic should be broken down to be trivial"}),"\n",(0,s.jsx)(n.li,{children:"beware of overenginiering and premature optimisation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"You Aint Gonna Need It (YAGNI)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"keep decisions open for as long as possible"}),"\n",(0,s.jsx)(n.li,{children:"build only what you need to build, stay flexible for future requirements"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Do Not Repeat Yourself (DRY)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"do not solve the same responsability or concern in multiple places"}),"\n",(0,s.jsx)(n.li,{children:"beware of things that look similar, but are not. for example, things that change for different reasons should not be combined, even if their code looks the same"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"server-layer-architecture",children:"Server Layer Architecture"}),"\n",(0,s.jsx)(n.p,{children:"We generally distinguish three different layers in our server architecture: The API Layer, the Repository Layer, and the Domain Layer."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Architecture Layers",src:i(7743).A+"",width:"1237",height:"677"})}),"\n",(0,s.jsx)(n.p,{children:"Note that based on the Dependency Inversion Principle, the Domain Layer does not have any dependencies. Instead, both the API and Repository Layer depend on its abstractions."}),"\n",(0,s.jsx)(n.h3,{id:"domain-layer",children:"Domain Layer"}),"\n",(0,s.jsx)(n.p,{children:"The Domain Layer contains the business logic of the application. As mentioned above, it is not allowed to know about anything outside the domain layer itself."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"API Layer Dependencies",src:i(5779).A+"",width:"1366",height:"675"})}),"\n",(0,s.jsxs)(n.p,{children:["Any operation within the system is defined by a ",(0,s.jsx)(n.em,{children:"usecase (UC)"}),". It describes how an external actor, for example a user, can interact with the system."]}),"\n",(0,s.jsxs)(n.p,{children:["Each usecase defines what needs to be done to authorize it, and what needs to be done to fulfill it. To this end, it orchestrates ",(0,s.jsx)(n.em,{children:"services"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"A service is a public part of a domain module, that provides an interface for logic. It might be a simple class doing simple calculations, an interface to a complex hierarchy of classes within a module, or anything in between."}),"\n",(0,s.jsx)(n.p,{children:"The domain layer might also define other classes, types, and interfaces to be used internally by its services, as well as the interface definitions for the repository layer. That way, the domain does not have to depend on the repositories, and the repositories have to depend on the domain instead (dependency inversion)"}),"\n",(0,s.jsx)(n.p,{children:"TODO: the exact way of implementing the interfaces between repositories and domain layer is still in active discussion and development within the architecture chapter"}),"\n",(0,s.jsx)(n.h3,{id:"api-layer",children:"API Layer"}),"\n",(0,s.jsx)(n.p,{children:"The API Layer is responsible for providing the API that is exposed outside the system, and to map the various incoming requests into domain DTOs."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"API Layer Dependencies",src:i(8143).A+"",width:"805",height:"652"})}),"\n",(0,s.jsx)(n.p,{children:"The params.dto and response.dto are used to automatically generate the API Documentation based on openAPI. The params.dto also contains information that is used for input validation."}),"\n",(0,s.jsx)(n.p,{children:"The controller is responsible for sanitizing and authenticating incoming requests, and to map to and from the format that the domain usecase implementations expect. To this end, mappers are being used."}),"\n",(0,s.jsx)(n.h3,{id:"repository-layer",children:"Repository Layer"}),"\n",(0,s.jsx)(n.p,{children:"The Repository Layer is responsible for outgoing requests to external services. The most prominent example is accessing the database, but the same principles apply for sending emails or other interactions with external systems."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Repository Layer Dependencies",src:i(7035).A+"",width:"606",height:"657"})}),"\n",(0,s.jsx)(n.p,{children:"In order to access these external systems without knowing them, the domain layer may define interfaces that describe how it would like to use external services in its own domain language. The repositories implement these interfaces, recieving and returning exclusively objects or dtos defined in the domain."}),"\n",(0,s.jsx)(n.p,{children:"The datamodel itself is defined through Entities, that have to be mapped into domain objects before they can be returned to the domain layer. We use MikroORM to create, persist and load the entities and their references among each other."}),"\n",(0,s.jsx)(n.h2,{id:"modules",children:"Modules"}),"\n",(0,s.jsx)(n.p,{children:"The codebase is broken into modules, each dealing with a part of the businesslogic, or seperated technical concerns.\nThese modules define what code is available where, and ensure a clean dependency graph."}),"\n",(0,s.jsx)(n.p,{children:"All Code written should be part of exactly one module. Each module contains any services, typedefinitions, interfaces, repositories, mappers, and other files it needs internally to function."}),"\n",(0,s.jsx)(n.p,{children:"When something is needed in more than one module, it needs to be explicitly exported by the module, to be part of its public interface. It can then be imported by other modules. Services are exported published via the dependency injection mechanism provided by Nestjs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@Module({\n  providers: [InternalRepo, InternalService, PublicService],\n  exports: [PublicService],\n})\nexport class ExampleModule {}\n\n@Module({\n  imports: [ExampleModule],\n  providers: [SomeOtherService],\n})\nexport class OtherModule {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that in the above example, the ",(0,s.jsx)(n.code,{children:"PublicService"})," can be used anywhere within the ",(0,s.jsx)(n.code,{children:"OtherModule"}),", including in the ",(0,s.jsx)(n.code,{children:"SomeOtherService"}),", whereas the ",(0,s.jsx)(n.code,{children:"InternalRepo"})," and ",(0,s.jsx)(n.code,{children:"InternalService"})," can not."]}),"\n",(0,s.jsx)(n.p,{children:"Things that cant be injectables, like types and interfaces, are exported via the index file at the root of the module."}),"\n",(0,s.jsx)(n.p,{children:"Code that needs to be shared across many modules can either be put into their own seperate module, if there is a clearly defined seperate concern covered by it, or into the shared module if not."}),"\n",(0,s.jsx)(n.h3,{id:"api-modules",children:"Api Modules"}),"\n",(0,s.jsx)(n.p,{children:"The controllers and the corresponding usecases, along with the api tests for these routes, are seperated into api modules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@Module({\n  imports: [ExampleModule],\n  providers: [ExampleUc],\n  controllers: [ExampleController],\n})\nexport class ExampleApiModule {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This allows us to include the domain modules in different server deployments, without each of them having all api definitions. This also means that no usecase can ever be imported, as only services are ever exported, enforcing a seperation of concerns between logic and orchestration."}),"\n",(0,s.jsx)(n.h2,{id:"horizontal-architecture",children:"Horizontal Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The application is split into different modules that implement different parts of our domain."}),"\n",(0,s.jsx)(n.p,{children:"The exact split of modules is still work in progress, or left open as implementation detail. Some important considerations are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"things with high cohesion and coupling should be in the same module"}),"\n",(0,s.jsx)(n.li,{children:"things with low coupling should be in seperate modules"}),"\n",(0,s.jsx)(n.li,{children:"the modules define an explicit public interface of usecases and types they expose to other modules"}),"\n",(0,s.jsx)(n.li,{children:"no module should ever try to access a class of a different module that is not explicitly exported"}),"\n",(0,s.jsx)(n.li,{children:"no injectable should ever be defined in more than one module"}),"\n",(0,s.jsx)(n.li,{children:"a module should only export services to be used by other modules."}),"\n",(0,s.jsx)(n.li,{children:"a module that other modules might need to import, especially in another mikroservice, should not contain controllers."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},5779:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/domain-layer-1f9aa85eeea03234d09d63d8b22c9770.png"},7035:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/repository-layer-634ac9a895170a50a06a139491e3bd38.png"},7743:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/clean-architecture-layers-0db3fbc34a2234fae940649582f0ab4b.png"},8143:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/api-layer-f535fa8f7470e60cfbfc1fb3e0e95bcd.png"},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);