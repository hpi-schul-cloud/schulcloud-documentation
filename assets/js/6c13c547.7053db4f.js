"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[8613],{3844:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"backend/Coding-Guidelines/event-handling","title":"Event Handling","description":"Internal Events are used as a mechanism for Dependency Inversion.","source":"@site/docs/backend/Coding-Guidelines/event-handling.md","sourceDirName":"backend/Coding-Guidelines","slug":"/backend/Coding-Guidelines/event-handling","permalink":"/docs/backend/Coding-Guidelines/event-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/backend/Coding-Guidelines/event-handling.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Domain Object Validation","permalink":"/docs/backend/Coding-Guidelines/domain-object-validation"},"next":{"title":"Exception Handling","permalink":"/docs/backend/Coding-Guidelines/exception-handling"}}');var s=t(4848),o=t(8453);const d={},r="Event Handling",a={},l=[{value:"How to implement Event Handling",id:"how-to-implement-event-handling",level:2},{value:"Defining an Event",id:"defining-an-event",level:3},{value:"Sending an Event",id:"sending-an-event",level:3},{value:"Recieving an Event",id:"recieving-an-event",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"event-handling",children:"Event Handling"})}),"\n",(0,s.jsx)(n.p,{children:"Internal Events are used as a mechanism for Dependency Inversion."}),"\n",(0,s.jsx)(n.p,{children:"If you are implementing an operation in a module that needs to trigger an operation in another module, that is simple if you can simply import a service. However, if that other module already has a dependency on your module, that would lead to a dependency cycle. In this case, you need to inverse one of the dependencies via events."}),"\n",(0,s.jsx)(n.p,{children:"The main thing you need to think about, is which module should know about which module(s). This is the dependency, and it only ever can point into one direction. As a general rule of thumb, the module that is more specific, or is changing more frequently, or is less central to the functionality of the system, should have the dependency on the other."}),"\n",(0,s.jsx)(n.p,{children:"In the following example, the course module has a dependency on the user module, but NOT vice versa."}),"\n",(0,s.jsx)(n.h2,{id:"how-to-implement-event-handling",children:"How to implement Event Handling"}),"\n",(0,s.jsx)(n.p,{children:"consider the following folder structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-txt",children:"- users\n  - api\n  - domain\n    - services\n    - events\n      - user-deleted.event.ts\n  - repo\n- courses\n  - api\n  - domain\n    - services\n    - handlers\n      - user-deleted.handler.ts\n  - repo\n"})}),"\n",(0,s.jsx)(n.p,{children:"each of the modules needs to import the CqrsModule"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// users.module.ts\nimport { Module } from '@nestjs/common';\nimport { CqrsModule } from '@nestjs/cqrs';\n\n@Module({\n    imports: [CqrsModule],\n    providers: [/* some things here */],\n    exports: [/* some things here */],\n})\nexport class GroupModule {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"defining-an-event",children:"Defining an Event"}),"\n",(0,s.jsx)(n.p,{children:"The event is in the end simply a class, containing any data required to handle the event"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// users/domain/events/user-deleted.event.ts\nexport class UserDeletedEvent {\n    id: EntityId\n\n    constructor(id: EntityId) {\n        this.id = id\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Make sure to make your event public in the index file of your module"}),"\n",(0,s.jsx)(n.h3,{id:"sending-an-event",children:"Sending an Event"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// users/domain/services/service.ts\nimport { EventBus } from '@nestjs/cqrs';\nimport { UserDeletedEvent } from '../events';\n\n@Injectable()\nexport class Service {\n    constructor(private readonly eventBus: EventBus) {}\n\n    public async delete(userId: EntityId): Promise<void> {\n        doStuffForDeletion()\n\n        await this.eventBus.publish(new UserDeletedEvent(userId));\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"recieving-an-event",children:"Recieving an Event"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// courses/domain/handler/user-deleted.handler.ts\nimport { UserDeletedEvent } from '@modules/users';\nimport { EventsHandler, IEventHandler } from '@nestjs/cqrs';\nimport { SomeService } from '../services'\n\n@Injectable()\n@EventsHandler(UserDeletedEvent)\nexport class GroupDeletedHandlerService implements IEventHandler<UserDeletedEvent> {\n    constructor(private readonly someService: SomeService) {}\n\n    public async handle(event: GroupDeletedEvent): Promise<void> {\n        await someService.doSomeStuff()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that the handler should not contain any logic, but only the orchestration of what needs to be done."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function d(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);