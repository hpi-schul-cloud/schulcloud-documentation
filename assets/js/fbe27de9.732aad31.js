"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[3413],{185:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/LogoutFromSVSByMoinSchule.drawio-090932aa4f661d86d5e401c50b007d33.svg"},781:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>h,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"services/moin-punkt-schule/concept","title":"Moin.Schule","description":"Schulconnex","source":"@site/docs/services/moin-punkt-schule/concept.md","sourceDirName":"services/moin-punkt-schule","slug":"/services/moin-punkt-schule/concept","permalink":"/docs/services/moin-punkt-schule/concept","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/services/moin-punkt-schule/concept.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Getting started Moin.Schule","permalink":"/docs/services/moin-punkt-schule/Getting started"},"next":{"title":"Concept provining","permalink":"/docs/services/provining/concept"}}');var s=t(4848),i=t(8453);const l={},h="Moin.Schule",r={},c=[{value:"Schulconnex",id:"schulconnex",level:2},{value:"What is Schulconnex?",id:"what-is-schulconnex",level:3},{value:"moin.schule and Schulconnex",id:"moinschule-and-schulconnex",level:2},{value:"Backchannel Logout from SVS to moin.schule",id:"backchannel-logout-from-svs-to-moinschule",level:2},{value:"Migrate the Logout to NestJs",id:"migrate-the-logout-to-nestjs",level:3},{value:"Save the refresh token from moin.schule",id:"save-the-refresh-token-from-moinschule",level:3},{value:"Keep the refresh token alive",id:"keep-the-refresh-token-alive",level:3},{value:"Send the refresh token to Keycloak for logout",id:"send-the-refresh-token-to-keycloak-for-logout",level:3},{value:"Refresh the refresh token",id:"refresh-the-refresh-token",level:2},{value:"Logout from moin.schule initiated in SVS",id:"logout-from-moinschule-initiated-in-svs",level:2},{value:"Logout from SVS initiated in moin.schule",id:"logout-from-svs-initiated-in-moinschule",level:2},{value:"Flow overview",id:"flow-overview",level:3},{value:"Graphical Flow",id:"graphical-flow",level:4},{value:"Validation Steps",id:"validation-steps",level:3},{value:"Endpoint Design",id:"endpoint-design",level:3}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"moinschule",children:"Moin.Schule"})}),"\n",(0,s.jsx)(n.h2,{id:"schulconnex",children:"Schulconnex"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-schulconnex",children:"What is Schulconnex?"}),"\n",(0,s.jsx)(n.p,{children:"Schulconnex is an interface (API) for the synchronization of identities and school context data.\nContextual data includes roles, group memberships, subjects, a school number, or information about educational programs."}),"\n",(0,s.jsx)(n.h2,{id:"moinschule-and-schulconnex",children:"moin.schule and Schulconnex"}),"\n",(0,s.jsx)(n.p,{children:"moin.schule implements Schulconnex. SVS communicates with moin.schule via Schulconnex."}),"\n",(0,s.jsx)(n.p,{children:"SVS calls the following Schulconnex-endpoints:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"person-info"}),"\n",(0,s.jsx)(n.li,{children:"policies-info"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Latest working version"}),"\n",(0,s.jsxs)(n.p,{children:["For Schulconnex documentation see: ",(0,s.jsx)(n.a,{href:"https://schulconnex.github.io/Schulconnex/",children:"https://schulconnex.github.io/Schulconnex/"})]}),"\n",(0,s.jsx)(n.h2,{id:"backchannel-logout-from-svs-to-moinschule",children:"Backchannel Logout from SVS to moin.schule"}),"\n",(0,s.jsx)(n.p,{children:"Whenever a user logs out of the SVS we want to log the user also out of moin.schule as well. This can be done by sending the session token from moin.schule to their Keycloak when we process the users logout from SVS."}),"\n",(0,s.jsx)(n.p,{children:"To achieve this we need to port some code and expand on it:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Move the Logout Endpoint to NestJs"}),"\n",(0,s.jsx)(n.li,{children:"Save the refresh token from moin.schule"}),"\n",(0,s.jsx)(n.li,{children:"Keep the refresh token alive"}),"\n",(0,s.jsx)(n.li,{children:"Send the refresh token to Keycloak for logout"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Lets go over them all one-by-one"}),"\n",(0,s.jsx)(n.h3,{id:"migrate-the-logout-to-nestjs",children:"Migrate the Logout to NestJs"}),"\n",(0,s.jsxs)(n.p,{children:["Logout is currently handled by the legacy server. We need to migrate the mechanism to NestJs. SVS logout works by unlisting the users JWT from the whitelist and clearing the cookie. The cookie clearing is done by the client, however the server deletes the JWT from the whitelist. The code to migrate is located ",(0,s.jsx)(n.a,{href:"https://github.com/hpi-schul-cloud/schulcloud-server/blob/622e80eda2e64cde84530527fbd71aacb571431f/src/services/authentication/hooks/index.js#L150",children:"here"}),". The linked hook is executed the route DELETE /api/v1/authentication. Thus we should create a similar endpoint in the authentication module. We already have all necessary infrastructure to access Redis in NestJs inside the CacheModule."]}),"\n",(0,s.jsx)(n.h3,{id:"save-the-refresh-token-from-moinschule",children:"Save the refresh token from moin.schule"}),"\n",(0,s.jsx)(n.p,{children:"When we call the token endpoint from moin.schule, we already receive the needed refresh token. This token just needs to be saved for the session in the server. We can use the current CacheWrapperModule to access Redis (Later this will be MongoDB, DevOps would appreciate this more, but this is very likely out-of-scope) and save the token there, similar to the SVS-JWT in the whitelist. The token itself has only a limited TTL, which is saved inside the token itself. I would argue that the token itself is saved with the token for easier access:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Key"}),(0,s.jsx)(n.th,{children:"Value"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{userId}:{systemId}:refreshtoken"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ token: {moin.schule refreshtoken}, ttl:{refreshtoken.ttl} }"})})]})})]}),"\n",(0,s.jsx)(n.p,{children:"To keep the session store clean, we should give the entry a reasonable TTL"}),"\n",(0,s.jsx)(n.h3,{id:"keep-the-refresh-token-alive",children:"Keep the refresh token alive"}),"\n",(0,s.jsxs)(n.p,{children:["The biggest challenge is to keep the token alive without overwhelming the system. A refresh token has only a limited lifetime and this needs to be updated regularly. As a first attempt we want to update the token whenever the user is authenticated against the SVS. The JWT Guard we are using can also be used to check on such information. A possible entry point for this is ",(0,s.jsx)(n.a,{href:"https://github.com/hpi-schul-cloud/schulcloud-server/blob/f454a653ada922422914bcaf6b341e08f26b3051/apps/server/src/modules/authentication/strategy/jwt.strategy.ts#L12",children:"https://github.com/hpi-schul-cloud/schulcloud-server/blob/f454a653ada922422914bcaf6b341e08f26b3051/apps/server/src/modules/authentication/strategy/jwt.strategy.ts#L12"}),", which checks the JWT."]}),"\n",(0,s.jsx)(n.p,{children:"The necessary steps to expand it are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a Service for checking the refresh_token","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This Service checks if the user is an external/moin.schule user"}),"\n",(0,s.jsx)(n.li,{children:"If it is, then check if a refresh_token is available"}),"\n",(0,s.jsx)(n.li,{children:"If the token has a TTL shorter than a specified time (probable through a global setting or ENV-VAR), then trigger a refresh"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Call to the external system to update the refresh_token","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use the already saved token endpoint in the OauthConfig of the system"}),"\n",(0,s.jsx)(n.li,{children:"The required call is as follows:"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Method: POST\nURL: <token-endpoint>\nBody type: x-www-form-urlencoded\nForm fields:    \nclient_id : <my-client-name>\ngrant_type : refresh_token\nrefresh_token: <my-refresh-token>\n"})}),"\n",(0,s.jsx)(n.p,{children:"The response is a complete new set of tokens though, we only save the refresh token though, as we have currently no use for the other tokens. The new token and TTL are saved in the store as mentioned in the section above."}),"\n",(0,s.jsx)(n.h3,{id:"send-the-refresh-token-to-keycloak-for-logout",children:"Send the refresh token to Keycloak for logout"}),"\n",(0,s.jsx)(n.p,{children:"Finally, to facilitate the logout we need to send the refresh token to the Keycloak. It requires the SVS to send the token to the dedicated logout endpoint of the provider. We should already save that endpoint inside our OAuthConfig for the provider."}),"\n",(0,s.jsx)(n.p,{children:"To log the user out of the Keycloak system we send a request similar to this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Method: POST\nURL: <logout-endpoint>\nHeader:\n\tAuth:\n\t\tusername: <clientId>\n\t\tpassword: <clientSecret>\nBody type: x-www-form-urlencoded\nForm fields:\nrefresh_token: <my-refresh-token>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Possible return values:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"204 if successful"}),"\n",(0,s.jsx)(n.li,{children:"400 with a detailed JSON message if not"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The response should not concern our functionality of the SVS logout. It is to be determined if the response matters to us, but for now we can reject it."}),"\n",(0,s.jsx)(n.h2,{id:"refresh-the-refresh-token",children:"Refresh the refresh token"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Not implemented"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"logout-from-moinschule-initiated-in-svs",children:"Logout from moin.schule initiated in SVS"}),"\n",(0,s.jsxs)(n.p,{children:["To have a clean logout for the users, we need to log the user out from moin.schule whenever they are logged out from the SVS. This can be achieved using a Keycloak-specific variant of ",(0,s.jsx)(n.em,{children:"RP-initiated Logout."})," A common method in the OIDC standard to tell an Identity Provider that a user should be logged out."]}),"\n",(0,s.jsx)(n.p,{children:"Moin.Schule offers the specified end_session_endpoints (Retrieved on 20.03.2024):"}),"\n",(0,s.jsxs)(n.p,{children:["Staging: ",(0,s.jsx)(n.a,{href:"https://auth.stage.niedersachsen-login.schule/realms/SANIS/protocol/openid-connect/logout",children:"https://auth.stage.niedersachsen-login.schule/realms/SANIS/protocol/openid-connect/logout"})]}),"\n",(0,s.jsxs)(n.p,{children:["Prod: ",(0,s.jsx)(n.a,{href:"https://auth.moin.schule/realms/moins/protocol/openid-connect/logout",children:"https://auth.moin.schule/realms/moins/protocol/openid-connect/logout"})]}),"\n",(0,s.jsx)(n.p,{children:"We also receive already the session token, however we currently discard it. Thus we have all required data present."}),"\n",(0,s.jsx)(n.p,{children:"The general flow would be as follows:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Logout Flow Diagram",src:t(3828).A+"",width:"300",height:"257"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Required changes to resolve the acceptens criteria."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"logout-from-svs-initiated-in-moinschule",children:"Logout from SVS initiated in moin.schule"}),"\n",(0,s.jsx)(n.p,{children:'Whenever a User logs out of moin.schule, we also want the user to be able to log out of the SVS as well, if they are logged in there through moin.schule. For this there exists the "OP-initiated Logout-Flow" in the OpenId Connect specification. moin.schule supports this through the underlying Keycloak. SVS on the other hand cannot handle this request yet. We need to integrate this into SVS according to the standard.'}),"\n",(0,s.jsx)(n.h3,{id:"flow-overview",children:"Flow overview"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The User logs out of moin.schule"}),"\n",(0,s.jsx)(n.li,{children:"moin.schule sends a Logout-JWT to all connected Clients, including SVS"}),"\n",(0,s.jsx)(n.li,{children:"SVS verifies the Logout-JWT"}),"\n",(0,s.jsx)(n.li,{children:"SVS logs the user out and returns OK to moin.schule"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"graphical-flow",children:"Graphical Flow"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"OIDC Logout Flow Diagram",src:t(185).A+""})}),"\n",(0,s.jsx)(n.h3,{id:"validation-steps",children:"Validation Steps"}),"\n",(0,s.jsx)(n.p,{children:"According to the OIDC Standard, these are the steps required to validate the Logout-JWT:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"If the Logout Token is encrypted, decrypt it using the keys and algorithms that the Client specified during Registration that the OP was to use to encrypt ID Tokens. If ID Token encryption was negotiated with the OP at Registration time and the Logout Token is not encrypted, the RP SHOULD reject it."}),"\n",(0,s.jsx)(n.li,{children:"Validate the Logout Token signature in the same way that an ID Token signature is validated, with the following refinements."}),"\n",(0,s.jsxs)(n.li,{children:["Validate the ",(0,s.jsx)(n.code,{children:"alg"})," (algorithm) Header Parameter in the same way it is validated for ID Tokens. Like ID Tokens, selection of the algorithm used is governed by the ",(0,s.jsx)(n.code,{children:"id_token_signing_alg_values_supported"})," Discovery parameter and the ",(0,s.jsx)(n.code,{children:"id_token_signed_response_alg"})," Registration parameter when they are used; otherwise, the value SHOULD be the default of ",(0,s.jsx)(n.code,{children:"RS256"}),". Additionally, an ",(0,s.jsx)(n.code,{children:"alg"})," with the value ",(0,s.jsx)(n.code,{children:"none"})," MUST NOT be used for Logout Tokens."]}),"\n",(0,s.jsxs)(n.li,{children:["Validate the ",(0,s.jsx)(n.code,{children:"iss"}),", ",(0,s.jsx)(n.code,{children:"aud"}),", ",(0,s.jsx)(n.code,{children:"iat"}),", and ",(0,s.jsx)(n.code,{children:"exp"})," Claims in the same way they are validated in ID Tokens."]}),"\n",(0,s.jsxs)(n.li,{children:["Verify that the Logout Token contains a ",(0,s.jsx)(n.code,{children:"sub"})," Claim, a ",(0,s.jsx)(n.code,{children:"sid"})," Claim, or both."]}),"\n",(0,s.jsxs)(n.li,{children:["Verify that the Logout Token contains an ",(0,s.jsx)(n.code,{children:"events"})," Claim whose value is JSON object containing the member name ",(0,s.jsx)(n.a,{href:"http://schemas.openid.net/event/backchannel-logout",children:"http://schemas.openid.net/event/backchannel-logout"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Verify that the Logout Token does not contain a ",(0,s.jsx)(n.code,{children:"nonce"})," Claim."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We can already do all these points, except for 3 and 4. We do not save these information for the login of the user. We can implement these at a later point, since the other points should give us enough security to log out the user reliably."}),"\n",(0,s.jsx)(n.p,{children:"Points 1 and 2 are already handled by the ID Token validation we implemented. we can reuse it verbatim. 5-7 are simply checking for claims in the JWT and can be easily implemented."}),"\n",(0,s.jsx)(n.h3,{id:"endpoint-design",children:"Endpoint Design"}),"\n",(0,s.jsx)(n.p,{children:"Finally we need to create a new logout endpoint, more precisely an OIDC logout endpoint. This Endpoint needs to be a public POST route with no Authentication that expects exactly one parameter, the logout token. The Endpoint, according to official documentation, should look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"POST /backchannel_logout HTTP/1.1\nHost: rp.example.org\nContent-Type: application/x-www-form-urlencoded\n\nlogout_token=eyJhbGci ... .eyJpc3Mi ... .T3BlbklE ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We need to decide where to put this Endpoint. my suggestion would be to place it in the Authentication module in a new controller especially for logouts. I suggest ",(0,s.jsx)(n.strong,{children:"/api/v3/logout/oidc"})," and in general create a fitting controller for future logout methods (such as the local logout)"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},3828:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/MoinSchuleLogout-ea149ead7579b8fa1141828ce17ad447.png"},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>h});var o=t(6540);const s={},i=o.createContext(s);function l(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);