"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[2526],{8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},9044:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"backend-design-patterns/Api","title":"API design","description":"nest.js","source":"@site/docs/backend-design-patterns/Api.md","sourceDirName":"backend-design-patterns","slug":"/backend-design-patterns/Api","permalink":"/docs/backend-design-patterns/Api","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/backend-design-patterns/Api.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Backend Design Patterns","permalink":"/docs/category/backend-design-patterns"},"next":{"title":"Access legacy Code","permalink":"/docs/backend-design-patterns/Coding-Guidelines/access-legacy-code"}}');var r=s(4848),o=s(8453);const i={},a="API design",c={},l=[{value:"nest.js",id:"nestjs",level:2},{value:"Responses",id:"responses",level:2}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"api-design",children:"API design"})}),"\n",(0,r.jsx)(n.h2,{id:"nestjs",children:"nest.js"}),"\n",(0,r.jsx)(n.p,{children:"In nest.js all apis are defined in controllers.\nUsually the api follows the following syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"'/api/v3/resource'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each controller is responsible for a specific resource."}),"\n",(0,r.jsx)(n.li,{children:"The controller is responsible for the routing and the validation of the request."}),"\n",(0,r.jsx)(n.li,{children:"The controller calls a service to handle the request."}),"\n",(0,r.jsx)(n.li,{children:"The service is responsible for the business logic."}),"\n",(0,r.jsx)(n.li,{children:"The service calls a repository to access the database."}),"\n",(0,r.jsx)(n.li,{children:"The repository is responsible for the database access."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"responses",children:"Responses"}),"\n",(0,r.jsx)(n.p,{children:"When returning a response like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"@Controller('cards')\nexport class CardController {\n    @ApiOperation({summary: 'Create a new element on a card.'})\n    @ApiExtraModels(\n        ExternalToolElementResponse,\n        FileElementResponse,\n        LinkElementResponse,\n        RichTextElementResponse,\n        SubmissionContainerElementResponse\n    )\n    @ApiResponse({\n        status: 201,\n        schema: {\n            oneOf: [\n                {$ref: getSchemaPath(ExternalToolElementResponse)},\n                {$ref: getSchemaPath(FileElementResponse)},\n                {$ref: getSchemaPath(LinkElementResponse)},\n                {$ref: getSchemaPath(RichTextElementResponse)},\n                {$ref: getSchemaPath(SubmissionContainerElementResponse)},\n            ],\n        },\n    })\n    @ApiResponse({status: 400, type: ApiValidationError})\n    @ApiResponse({status: 403, type: ForbiddenException})\n    @ApiResponse({status: 404, type: NotFoundException})\n    @Post(':cardId/elements')\n    public async createElement(\n\t\t@Param() urlParams: CardUrlParams,\n\t\t@Body() bodyParams: CreateContentElementBodyParams,\n\t\t@CurrentUser() currentUser: ICurrentUser\n\t): Promise<AnyContentElementResponse> {\n        const {type, toPosition} = bodyParams;\n        const element = await this.cardUc.createElement(currentUser.userId, urlParams.cardId, type, toPosition);\n        const response = ContentElementResponseFactory.mapToResponse(element);\n\n        return response;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We want to use decorators to explain the intent of the response.",(0,r.jsx)(n.br,{}),"\n","The ",(0,r.jsx)(n.code,{children:"@ApiOperation"})," decorator is used to define the summary.",(0,r.jsx)(n.br,{}),"\n","The ",(0,r.jsx)(n.code,{children:"@ApiResponse"})," decorator is used to define the response.",(0,r.jsx)(n.br,{}),"\n","The ",(0,r.jsx)(n.code,{children:"@ApiExtraModels"})," decorator is used to define the response models."]}),"\n",(0,r.jsxs)(n.p,{children:["The final response should either be an javascript Object or an array.\nWe do not return primitives like ",(0,r.jsx)(n.code,{children:"string"})," or ",(0,r.jsx)(n.code,{children:"boolean"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Swagger will automatically generate the response schema from the response object."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);