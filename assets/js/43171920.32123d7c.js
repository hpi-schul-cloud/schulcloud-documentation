"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[3224],{2885:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"frontend/ComponentGuidelines","title":"Component Development Guidelines","description":"HTML is not a string","source":"@site/docs/frontend/ComponentGuidelines.md","sourceDirName":"frontend","slug":"/frontend/ComponentGuidelines","permalink":"/docs/frontend/ComponentGuidelines","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/frontend/ComponentGuidelines.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Hints for Working","permalink":"/docs/frontend/HintsForWorking"},"next":{"title":"End-to-end System Tests","permalink":"/docs/category/end-to-end-system-tests"}}');var s=t(4848),l=t(8453);const o={sidebar_position:11},r="Component Development Guidelines",a={},d=[{value:"HTML is not a string",id:"html-is-not-a-string",level:2},{value:"Composition over Configuration",id:"composition-over-configuration",level:2},{value:"Using slots for highly flexible ui components",id:"using-slots",level:3},{value:"Destructure data over multiple components",id:"destructure-data-in-component-trees",level:3},{value:"Destructuring Data",id:"destructuring-data",level:4},{value:"Option 1 - Passing the prop",id:"option-1---passing-the-prop",level:4},{value:"Option 2 - provide/inject",id:"option-2---provideinject",level:4},{value:"Naming components in destructured component trees",id:"naming-in-destructured-trees",level:3}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"component-development-guidelines",children:"Component Development Guidelines"})}),"\n",(0,s.jsx)(n.h2,{id:"html-is-not-a-string",children:"HTML is not a string"}),"\n",(0,s.jsx)(n.p,{children:"Imagine writing a basic component to add reusable buttons to your app.\nThe first iteration might look like this when using it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<my-button></my-button>\n"})}),"\n",(0,s.jsx)(n.p,{children:"The next step might be adding a way to set the button label."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<my-button :label=\"'MyButton'\"></my-button>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Careful! The label-prop is just a ",(0,s.jsx)(n.strong,{children:"string"}),". This will limit your Button to only being able to have text-based Labels in the future. It is a lot less flexible because the ",(0,s.jsx)(n.strong,{children:"power of HTML was removed completely"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Compare it to this button:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<my-button>MyButton</my-button>\n"})}),"\n",(0,s.jsx)(n.p,{children:"The label stays within the realm of HTML and we don't lose any HTML capabilities:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<my-button>Two Line <br> Button!</my-button>\n\n<my-button>Button with <my-icon :icon="mdiCheck" /> in the label!</my-button>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Both of these examples are (almost) impossible with a prop-based label."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rule:"})," Readable text should be HTML and not a string-prop."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"composition-over-configuration",children:"Composition over Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"using-slots",children:"Using slots for highly flexible ui components"}),"\n",(0,s.jsx)(n.p,{children:"Let's build a simple vertical-menu with two clickable options and add more and more requirements as we go."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Requirements"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Menu with two clickable options"}),"\n"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<ul>\n  <li>\n    <my-button>Option 1</my-button>\n  </li>\n  <li>\n    <my-button>Option 2</my-button>\n  </li>\n</ul>\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Updated Requirements"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.del,{children:"Menu with two clickable options"})}),"\n",(0,s.jsx)(n.li,{children:"Menu with any number of clickable options"}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"To make our menu reusable, one approach might be to add an options prop:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!-- MyMenu.component.vue--\x3e\n<template>\n  <ul>\n    <li v-for="let option in options">\n      <my-button @click="option.action">{{option.label}}</my-button>\n    </li>\n  </ul>\n</template>\n\n\x3c!-- usage --\x3e\n\n<my-menu \n  :options="[\n             { label: "Option 1", action: callback1 }, \n             { label: "Option 2", action: callback2 },\n            ]">\n</my-menu>\n'})}),"\n",(0,s.jsx)(n.p,{children:"This approach has two major problems:"}),"\n",(0,s.jsxs)(n.p,{children:["First you probably already notice that we demoted the label from HTML to being just a string again. ",(0,s.jsxs)(n.em,{children:["(See: ",(0,s.jsx)(n.a,{href:"#html-is-not-a-string",children:"HTML is not a string"}),")"]})]}),"\n",(0,s.jsx)(n.p,{children:"Second we abstracted the structure of our menu into an Array. This replaces perfectly good HTML with a datastructure."}),"\n",(0,s.jsx)(n.p,{children:"Take a look at this HTML-based approach:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<my-menu>\n  <my-menu-option @click="callback1">Option 1</my-menu-option>\n  <my-menu-option @click="callback2">Option 2</my-menu-option>\n</my-menu>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The original HTML-structure is preserved and only the default elements (",(0,s.jsx)(n.code,{children:"ul"}),", ",(0,s.jsx)(n.code,{children:"li"}),", ",(0,s.jsx)(n.code,{children:"button"}),") are abstracted in their own components. This leaves a lot of flexibility to interact with the structure (e.g. toggling options with v-if) while still making sure that the rendered output is valid."]}),"\n",(0,s.jsx)(n.p,{children:"Additionally, this is much easier to test since we do not have to deal with datastructures."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Updated Requirements"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Menu with any number of clickable options"}),"\n",(0,s.jsx)(n.li,{children:"Menu-Options can be colored"}),"\n",(0,s.jsx)(n.li,{children:"Any number of Menu-Dividers can be placed at any position in the menu"}),"\n"]})]}),"\n",(0,s.jsxs)(n.p,{children:["Adding these new requirements in the HTML approach is very straightforward. We just have to add a prop to each ",(0,s.jsx)(n.code,{children:"my-menu-option"})," to pick a color. Then we create a new ",(0,s.jsx)(n.code,{children:"my-menu-divider"})," component."]}),"\n",(0,s.jsxs)(n.p,{children:["Expanding the datastructure to support colors is easy, we just have to add a ",(0,s.jsx)(n.code,{children:"color"}),"-property. But the divider will be an actual problem. So far the datastructure was created to represent buttons. By adding the divider config object we will lose any uniformity of our config data. This will make it difficult to read, complicated to test und generally annoying to maintain."]}),"\n",(0,s.jsx)(n.p,{children:"Compare the two solutions in code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"\x3c!-- HTML approach --\x3e\n<my-menu>\n  <my-menu-option @click=\"callback1\">Option 1</my-menu-option>\n  <my-menu-divider />\n  <my-menu-option :color=\"'red'\" @click=\"callback2\">\n    Option 2\n  </my-menu-option>\n</my-menu>\n\n\x3c!-- Datastructure approach --\x3e\n<my-menu \n  :options=\"[\n             { label: \"Option 1\", action: callback1, color: 'default', type:'button' }, \n             { type: 'divider' },\n             { label: \"Option 2\", action: callback2, color: 'red', type:'button' },\n            ]\">\n</my-menu>\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can already see the datastructure approach falling apart. For complex menus this will be completely ineligible and difficult to understand."}),"\n",(0,s.jsx)(n.p,{children:"Let's add more requirements to get closer to a real world menu."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New Requirements"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Menu with any number of clickable options"}),"\n",(0,s.jsx)(n.li,{children:"Menu-Options can be colored"}),"\n",(0,s.jsx)(n.li,{children:"Any number of Menu-Dividers can be placed at any position in the menu"}),"\n",(0,s.jsx)(n.li,{children:"Menu-Options should have a disabled state"}),"\n",(0,s.jsx)(n.li,{children:"Menu-Options can be a button or link"}),"\n",(0,s.jsx)(n.li,{children:"Menu-Options can be nested dropdowns"}),"\n"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!-- HTML approach --\x3e\n<my-menu>\n  <my-menu-option @click="callback1" :disabled="true">Option 1</my-menu-option>\n  <my-menu-divider />\n  <my-menu-option :color="\'red\'" @click="callback2">Option 2</my-menu-option>\n  <my-menu-link :href="\'wikipedia.com\'">Link 1</my-menu-option>\n  <my-menu-nested-option>\n    <template #default> \x3c!--Default slot for button label--\x3e\n      Nested Option \n    </template>\n    <template #options> \x3c!--Named slot for options in the inner menu--\x3e\n       <my-menu-option @click="callback3">Option 3</my-menu-option>\n       <my-menu-divider />\n       <my-menu-option @click="callback4">Option 4</my-menu-option>\n    </template>\n  </my-menu-nested-option>\n</my-menu>\n\n\x3c!--Datastructure approach--\x3e\n\n<good-luck>\ud83d\ude05</good-luck>\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rule:"})," Use Slots and small subcomponents to create robust and flexible features."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rule:"})," Do not use datastructures to represent HTML."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"destructure-data-in-component-trees",children:"Destructure data over multiple components"}),"\n",(0,s.jsx)(n.p,{children:"We often have to deal with complex data that we want to show to the user."}),"\n",(0,s.jsx)(n.p,{children:"Take a look at this simplified example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const users: User[] = [\n  {\n    id: 1,\n    name: 'User 1',\n    email: 'user1@example.com'\n  },\n  {\n    id: 2,\n    name: 'User 2',\n    email: 'user2@example.com'\n  }\n]\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Requirements"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Display the User Array in a table"}),"\n"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<table>\n  <thead>\n    <tr>\n      <th>ID</th>\n      <th>Name</th>\n      <th>Email</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr v-for="let user in users">\n      <td>{{user.id}}</td>\n      <td>{{user.name}}</td>\n      <td>{{user.email}}</td>\n    </tr>\n  </tbody>\n</table>\n'})}),"\n",(0,s.jsx)(n.p,{children:"This template will quickly get large and hard to understand if we were to add styling, more fields of our user object or even interactions like editing or deleting entries."}),"\n",(0,s.jsx)(n.p,{children:"How can we easily split up the template?"}),"\n",(0,s.jsx)(n.h4,{id:"destructuring-data",children:"Destructuring Data"}),"\n",(0,s.jsxs)(n.p,{children:["A rule of thumb can be to not handle more than one level of your data structure in a single component. The ",(0,s.jsx)(n.code,{children:"User"})," object consists of three levels:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Array"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Object"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Property"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We can use this list to create subcomponents for the table:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"UserTable"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"the host component where all components come together"}),"\n",(0,s.jsx)(n.p,{children:"This will also be the outside Api of our implementation"}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"UserTableBody"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Component responsible for the ",(0,s.jsx)(n.code,{children:"Array"}),"-level of our data"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"UserTableRow"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Component responsible for the ",(0,s.jsx)(n.code,{children:"Object"}),"-level of our data"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"UserTableHeader"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Encapsulate ",(0,s.jsx)(n.code,{children:"<thead>"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!--UserTable.vue--\x3e\n\x3c!--props: User[]--\x3e\n<template>\n  <user-table-head />\n  <user-table-body :users="users"></user-table-body>\n</template>\n\n\x3c!--UserTableHead.vue--\x3e\n<template>\n  <thead>\n    <tr>\n      <th>ID</th>\n      <th>Name</th>\n      <th>Email</th>\n    </tr>\n  </thead>\n</template>\n\n\x3c!--UserTableBody.vue--\x3e\n\x3c!--props: User[]--\x3e\n<template>\n  <tbody>\n    <user-table-row v-for="let user in users" :user="user">\n    </user-table-row>\n  </tbody>\n</template>\n\n\x3c!--UserTableRow.vue--\x3e\n\x3c!--props: User--\x3e\n<template>\n  <tr>\n    <td>{{user.id}}</td>\n    <td>{{user.name}}</td>\n    <td>{{user.email}}</td>\n  </tr>\n</template>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Splitting up the table into these sub-components keeps the template short and less complex. It also makes testing much easier since each level is only concerned about a certain part of the complexity in the data."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New Requirements"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Display the User Array in a table"}),"\n",(0,s.jsx)(n.li,{children:"Deleting users should be possible"}),"\n"]})]}),"\n",(0,s.jsxs)(n.p,{children:["To add the new interaction button we will have to place it at the end of each row. To have a more pronounced structure we will place this button in a new component ",(0,s.jsx)(n.code,{children:"UserTableActions"}),". This creates a well defined place for adding more actions in the future. We also have to expand ",(0,s.jsx)(n.code,{children:"UserTableHead"})," by one ",(0,s.jsx)(n.code,{children:"<th>"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!--UserTableRow.vue--\x3e\n\x3c!--props: User--\x3e\n<template>\n  <tr>\n    <td>{{user.id}}</td>\n    <td>{{user.name}}</td>\n    <td>{{user.email}}</td>\n    <td>\n      <user-table-actions @delete="onDelete" @edit="onEdit"/>\n    </td>\n  </tr>\n</template>\n\n\x3c!--UserTableActions.vue--\x3e\n<template>\n  <button @click="emit(\'delete\')">Delete</button>\n</template>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Adding this action also reveals the biggest disadvantage of this approach: ",(0,s.jsxs)(n.strong,{children:["We have to pass the emit all the way up to ",(0,s.jsx)(n.code,{children:"UserTable"})," component"]}),". Since all children of ",(0,s.jsx)(n.code,{children:"UserTable"})," are ui-components they cannot access any state or the api."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Updated Requirements"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Display the User Array in a table"}),"\n",(0,s.jsx)(n.li,{children:"Deleting users should be possible"}),"\n",(0,s.jsx)(n.li,{children:"Delete button should be disabled while an async request is pending"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's ignore state interactions for this example. But to fulfil this requirement we will add a ",(0,s.jsx)(n.code,{children:"disabled"}),"-prop to ",(0,s.jsx)(n.code,{children:"UserTable"})," so that our outside logic can disable the buttons while requests are pending. But how do we deal with this internally."]}),"\n",(0,s.jsx)(n.h4,{id:"option-1---passing-the-prop",children:"Option 1 - Passing the prop"}),"\n",(0,s.jsx)(n.p,{children:"We can pass the disabled value through our whole component tree. That is a completely valid and comparatively easy solution but it can quickly create a lot of boilerplate."}),"\n",(0,s.jsx)(n.h4,{id:"option-2---provideinject",children:"Option 2 - provide/inject"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://vuejs.org/guide/components/provide-inject.html#prop-drilling",children:"Vue Docs: Prop-Drilling & provide/inject"}),". This can safe some development time since we don't have to deal with all the boilerplate of ",(0,s.jsx)(n.em,{children:"Option 1"}),"\nbut it can also lead to a mess of injections if not used carefully. Since this table and it's children are already heavily dependant on each other (they serve one shared purpose: Displaying a User-Table) we can use prop-drilling if we keep the injection-key as a private property of the module."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Updated Requirements"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Display the User Array in a table"}),"\n",(0,s.jsx)(n.li,{children:"Deleting users should be possible"}),"\n",(0,s.jsx)(n.li,{children:"Delete button should be disabled while an async request is pending"}),"\n",(0,s.jsx)(n.li,{children:"The Email should be a mailto-Link"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Remember the three levels of our data: ",(0,s.jsx)(n.code,{children:"Array"})," > ",(0,s.jsx)(n.code,{children:"Object"})," > ",(0,s.jsx)(n.code,{children:"Property"}),".\nSo far we have destructured the ",(0,s.jsx)(n.code,{children:"Array"})," and ",(0,s.jsx)(n.code,{children:"Object"})," levels into separate components. The new requirement could be implemented like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!--UserTableRow.vue--\x3e\n\x3c!--props: User--\x3e\n<template>\n  <tr>\n    <td>{{user.id}}</td>\n    <td>{{user.name}}</td>\n    <td>\n      <a :href="\'mailto:\' + user.email">{{user.email}}</a>\n    </td>\n    <td>\n      <user-table-actions @delete="onDelete" @edit="onEdit"/>\n    </td>\n  </tr>\n</template>\n'})}),"\n",(0,s.jsx)(n.p,{children:"While this template is still easy to understand in this simplified example, if we imagine a table with over 10 columns and a few lines of HTML for each table-cell we can see that this will get messy quite quickly."}),"\n",(0,s.jsxs)(n.p,{children:["A great possibility to keep the template clean is to destructure one more level, down to the ",(0,s.jsx)(n.code,{children:"Property"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!--UserTableRow.vue--\x3e\n\x3c!--props: User--\x3e\n<template>\n  <tr>\n    <td>{{user.id}}</td>\n    <td>{{user.name}}</td>\n    <td>\n      <user-table-cell-email :email="user.email" />\n    </td>\n    <td>\n      <user-table-actions @delete="onDelete" @edit="onEdit"/>\n    </td>\n  </tr>\n</template>\n\n\x3c!--UserTableCellEmail.vue--\x3e\n\x3c!--props: String--\x3e\n<template>\n  <a :href="\'mailto:\' + email">{{email}}</a>\n</template>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that we did not create components for the ",(0,s.jsx)(n.code,{children:"id"})," and ",(0,s.jsx)(n.code,{children:"name"})," properties. Since they are not handled any differently they can just be shown using interpolation."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rule"}),": Create a sub-component for each meaningful level in your data"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rule"}),": Use ",(0,s.jsx)(n.code,{children:"provide/inject"})," of props only in small and defined scopes"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"naming-in-destructured-trees",children:"Naming components in destructured component trees"}),"\n",(0,s.jsx)(n.p,{children:"Destructuring data over components can lead to many small components and picking meaningful names can become a challenge."}),"\n",(0,s.jsx)(n.p,{children:"To find a name without much effort whenever I am creating components I use a pattern-based approach:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"<feature identifier><level><specific description>"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's analyze the naming in the ",(0,s.jsx)(n.code,{children:"UserTable"})," example to illustrate the pattern:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"UserTable"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The root component of the implementation. Its name consists of the feature identifier ",(0,s.jsx)(n.code,{children:"UserTable"})," and nothing else."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UserTableHead"}),", ",(0,s.jsx)(n.code,{children:"UserTableBody"})," and ",(0,s.jsx)(n.code,{children:"UserTableRow"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The children of the root component are named by the feature identifier and their appriopriate levels in the table: ",(0,s.jsx)(n.code,{children:"Head"}),", ",(0,s.jsx)(n.code,{children:"Body"})," and ",(0,s.jsx)(n.code,{children:"Row"}),". They are still quite general components and do not need a specific description since they are unique to their levels."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"UserTableCellEmail"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"This is a highly specific component and therefore includes the feature identifier, the level and a specific description to reflect its specific usecase."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Following this pattern makes it quite easy to name things while destructuring. It also leads to a well organized folder in the workspace explorer since components on the same level will be listed closely together - e.g. all ",(0,s.jsx)(n.code,{children:"UserTableCell"}),'-components have the same "prefix".']}),"\n",(0,s.jsxs)(n.p,{children:["The most difficult part in my experience is finding a good name for the ",(0,s.jsx)(n.code,{children:"level"}),"-part of the name. I usually try to use names that reflect the component as an HTML-Element: names of the part of a table, ",(0,s.jsx)(n.code,{children:"list"})," and ",(0,s.jsx)(n.code,{children:"list-item"})," for list-structures or ",(0,s.jsx)(n.code,{children:"option"})," when dealing with dropdowns etc."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},l=i.createContext(s);function o(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);