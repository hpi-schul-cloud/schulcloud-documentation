"use strict";(self.webpackChunkdataport_docusaurus=self.webpackChunkdataport_docusaurus||[]).push([[240],{3162:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"backend/Coding-Guidelines/solving-dependency-cycles","title":"Solving Dependency Cycles","description":"A dependency Cycle occurs, whenever two modules or files have mutual dependencies on each other.","source":"@site/docs/backend/Coding-Guidelines/solving-dependency-cycles.md","sourceDirName":"backend/Coding-Guidelines","slug":"/backend/Coding-Guidelines/solving-dependency-cycles","permalink":"/docs/backend/Coding-Guidelines/solving-dependency-cycles","draft":false,"unlisted":false,"editUrl":"https://github.com/hpi-schul-cloud/hpi-schul-cloud.github.io/blob/main/docs/backend/Coding-Guidelines/solving-dependency-cycles.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Repositories","permalink":"/docs/backend/Coding-Guidelines/repositories"},"next":{"title":"Testing","permalink":"/docs/backend/Coding-Guidelines/testing"}}');var o=t(4848),s=t(8453);const r={},c="Solving Dependency Cycles",l={},a=[{value:"Extracting a module",id:"extracting-a-module",level:2},{value:"Dependency Inversion",id:"dependency-inversion",level:2},{value:"Registry",id:"registry",level:2},{value:"Event Handling",id:"event-handling",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"solving-dependency-cycles",children:"Solving Dependency Cycles"})}),"\n",(0,o.jsx)(n.p,{children:"A dependency Cycle occurs, whenever two modules or files have mutual dependencies on each other."}),"\n",(0,o.jsx)(n.p,{children:"NestJS employs a mechanism to automatically solve some dependency cycles, but breaks down at a certain number. This often leads to errors that are very hard to debug and find the cause for. Therefore, its important to eliminate all potential dependency cycles before they can cause issues during development."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"No matter the circumstance, between any two files or modules, only one may depend on (know about, import) the other."})}),"\n",(0,o.jsx)(n.p,{children:"In the following, we will look at a simplified example, and discuss common strategies on how to resolve the cycle."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// A.ts\nimport { B } from './b';\n\nexport class A {\n\tconstructor(private readonly b: B) {}\n\n\tpublic someFunctionOnA(): void {\n\t\tconsole.log('Hello from A');\n\t}\n\n\tpublic someFunctionCallingB(): void {\n\t\tthis.b.someFunctionOnB();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// B.ts\nimport { A } from './a';\n\nexport class B {\n\tconstructor(private readonly a: A) {}\n\n\tpublic someFunctionOnB(): void {\n\t\tconsole.log('Hello from B');\n\t}\n\n\tpublic someFunctionCallingA(): void {\n\t\tthis.a.someFunctionOnA();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note that at the top of each file, the other file is being imported. This is a very simple dependency cycle."}),"\n",(0,o.jsx)(n.h2,{id:"extracting-a-module",children:"Extracting a module"}),"\n",(0,o.jsxs)(n.p,{children:["One of the easiest ways to resolve a cycle, is to recognise a part in one of the modules that is needed by both, but can be logically seperated into its own file or module. In this case, lets assume that ",(0,o.jsx)(n.code,{children:"someFunctionOnA"})," contains logic that both ",(0,o.jsx)(n.code,{children:"A"})," and ",(0,o.jsx)(n.code,{children:"B"})," need, but at closer inspection shows to not be dependent on any other part of ",(0,o.jsx)(n.code,{children:"A"}),". When this is the case, we can extract it from ",(0,o.jsx)(n.code,{children:"A"}),", creating a new Module ",(0,o.jsx)(n.code,{children:"C"}),", that both ",(0,o.jsx)(n.code,{children:"A"})," and ",(0,o.jsx)(n.code,{children:"B"})," will import."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// A.ts\nimport { B } from './b';\nimport { C } from './c';\n\nexport class A {\n\tconstructor(private readonly b: B, private readonly c: C) {}\n\n\tpublic someFunctionOnA(): void {\n\t\tthis.c.someFunctionOnC();\n\t}\n\n\tpublic someFunctionCallingB(): void {\n\t\tthis.b.someFunctionOnB();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// B.ts\nimport { C } from './c';\n\nexport class B {\n\tconstructor(private readonly c: C) {}\n\n\tpublic someFunctionOnB(): void {\n\t\tconsole.log('Hello from B');\n\t}\n\n\tpublic someFunctionCallingA(): void {\n\t\tthis.c.someFunctionOnC();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// C.ts\nexport class C {\n\tpublic someFunctionOnC(): void {\n\t\tconsole.log('Hello from A');\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, often times we dont get so lucky as to find the offending part of A to be independent of the rest. In that case, we have to invert one of the dependencies."}),"\n",(0,o.jsx)(n.h2,{id:"dependency-inversion",children:"Dependency Inversion"}),"\n",(0,o.jsx)(n.p,{children:"Dependency Inversion, also knows as inversion of control is a technique that allows the called module to depend on the calling module, instead of the other way around."}),"\n",(0,o.jsx)(n.p,{children:"This allows developers and architects to freely choose the direction of a dependency, by inverting any dependencies that are pointing the wrong way. This is useful both to avoid cycles, as well as to ensure changes in volatile modules do not force stable modules to change, by ensuring that volatile modules depend on stable modules, and not the other way around. It is also commonly used in architecture patterns like the onion architecture, which stipulate that all dependencies shall point from the outer layers of the architecture, to the inner layers."}),"\n",(0,o.jsxs)(n.p,{children:["For our example, lets assume that ",(0,o.jsx)(n.code,{children:"A"})," shall be allowed to depend on (know about) ",(0,o.jsx)(n.code,{children:"B"}),", but ",(0,o.jsx)(n.code,{children:"B"})," shall not be allowed to know ",(0,o.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The easiest and most common way to invert a dependency is by introducing an interface. In this case, ",(0,o.jsx)(n.code,{children:"B"})," would define an interface describing what requirements it has for its would-be-requirement. Then it no longer needs to import ",(0,o.jsx)(n.code,{children:"A"}),", but simply expect to be passed any object that satisfies the defined interface.\n",(0,o.jsx)(n.code,{children:"A"})," On the other hand, being allowed to know about ",(0,o.jsx)(n.code,{children:"B"}),", also knows about the interface, and can implement it."]}),"\n",(0,o.jsxs)(n.p,{children:["Note that at runtime, ",(0,o.jsx)(n.code,{children:"B"})," will be given ",(0,o.jsx)(n.code,{children:"A"})," and call its functions directly. However, it will not ",(0,o.jsx)(n.em,{children:"know"})," that the thing its operating on is ",(0,o.jsx)(n.code,{children:"A"}),'. This is an important distinction. We assume that the system has some kind of "main function", or in our case the dependency injection system, wich is responsible to correctly assemble all parts of the system, and will ensure during startup that all modules have all their dependencies satisfied.']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// A.ts\nimport { B, WhatBNeeds } from './b';\n\nexport class A implements WhatBNeeds {\n\tconstructor(private readonly b: B) {}\n\n\tpublic someFunctionOnA(): void {\n\t\tconsole.log('Hello from A');\n\t}\n\n\tpublic someFunctionCallingB(): void {\n\t\tthis.b.someFunctionOnB();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// B.ts\nexport interface WhatBNeeds {\n\tsomeFunctionOnA(): void;\n}\n\nexport class B {\n\tconstructor(private readonly a: WhatBNeeds) {}\n\n\tpublic someFunctionOnB(): void {\n\t\tconsole.log('Hello from B');\n\t}\n\n\tpublic someFunctionCallingA(): void {\n\t\tthis.a.someFunctionOnA();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"registry",children:"Registry"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes the Dependency you want to invert is not just on a single service or file, but actually an arbitrary number of similar services with a common interface (for example strategies). If you need to invert these dependencies, you might introduce a registry (and you might want to do it anyway just to reduce complexity)."}),"\n",(0,o.jsx)(n.p,{children:'All Services that implement the common interface and may be used by a Caller will "register" themselves on a central service (the "registry"). A caller then only needs to know about the registry, and can use it to either fetch the correct service, or to redirect his request to the correct recipient.'}),"\n",(0,o.jsxs)(n.p,{children:["In the upcoming example, ",(0,o.jsx)(n.code,{children:"A"})," represents one of an arbitrary amount of services that need to be registered."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// registry.ts\nexport interface ThingThatIsRegistered {\n\tsomeFunctionOnA(): void;\n}\n\nexport class Registry {\n\tprivate registry: Record<string, ThingThatIsRegistered> = {};\n\n\tpublic register(name: string, thing: ThingThatIsRegistered): void {\n\t\tthis.registry[name] = thing;\n\t}\n\n\tpublic get(name: string): ThingThatIsRegistered {\n\t\treturn this.registry[name];\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// A.ts\nimport { B } from './b';\nimport { Registry, ThingThatIsRegistered } from './registry';\n\nexport class A implements ThingThatIsRegistered {\n\tconstructor(private readonly b: B, registry: Registry) {\n\t\tregistry.register('a', this);\n\t}\n\n\tpublic someFunctionOnA(): void {\n\t\tconsole.log('Hello from A');\n\t}\n\n\tpublic someFunctionCallingB(): void {\n\t\tthis.b.someFunctionOnB();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// B.ts\nimport { Registry } from './registry';\n\nexport class B {\n\tconstructor(private readonly registry: Registry) {}\n\n\tpublic someFunctionOnB(): void {\n\t\tconsole.log('Hello from B');\n\t}\n\n\tpublic someFunctionCallingA(): void {\n\t\tthis.registry.get('a').someFunctionOnA();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note that in this example, we give every registered service an identifier to fetch it by. In real code, this might be an enum of some kind.\nHowever its also possible to build a registry without such an identifier, if the registry is able to figure out from the parameters of a call who the recipient should be. One way of accomplishing this is to ask each service in turn if he is able to process a particular request until it finds the correct one (or throw an error if it cant find one). You might even allow the same request to be processed by multiple services."}),"\n",(0,o.jsx)(n.h2,{id:"event-handling",children:"Event Handling"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes you dont want to call a single service from among an arbitrary number, but all of them. In this case, we want an event handler."}),"\n",(0,o.jsx)(n.p,{children:"An Event is something that allows its clients to register a handler function. When the event is triggered, all registered functions are called."}),"\n",(0,o.jsxs)(n.p,{children:["The pattern itself is widely used and already implemented in browser-based Javascript, and in our NestJS applications we use a powerful eventbus based on the nestjs-cqrs library. For more information see ",(0,o.jsx)(n.a,{href:"/docs/backend/Coding-Guidelines/event-handling",children:"event handling"}),". ",(0,o.jsx)(n.em,{children:"Whenever you need events in our backend applications, refer to that page"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"However for the completeness and simplicity of this explanation, we will show an example of a very primitive, self implemented eventhandling."}),"\n",(0,o.jsx)(n.p,{children:"The idea is very simple: the module that will trigger the event allows other services to register a function as eventhandler, and keeps those functions in an array. When the event is triggered, it calls those functions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// A.ts\nimport { B } from './b';\n\nexport class A {\n\tconstructor(private readonly b: B) {\n\t\t// .bind is important so that the function will have the context of this class when it is called\n\t\tb.registerEventHandler(this.someFunctionOnA.bind(this));\n\t}\n\n\tpublic someFunctionOnA(): void {\n\t\tconsole.log('Hello from A');\n\t}\n\n\tpublic someFunctionCallingB(): void {\n\t\tthis.b.someFunctionOnB();\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// B.ts\nexport class B {\n\tprivate handlers = Array<() => void>();\n\n\tpublic registerEventHandler(handler: () => void): void {\n\t\tthis.handlers.push(handler);\n\t}\n\n\tpublic someFunctionOnB(): void {\n\t\tconsole.log('Hello from B');\n\t}\n\n\tpublic someFunctionCallingA(): void {\n\t\tthis.handlers.forEach((handler) => {\n\t\t\thandler();\n\t\t});\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"/docs/backend/detect-dependency-cycles",children:"how to detect dependency cycles"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);